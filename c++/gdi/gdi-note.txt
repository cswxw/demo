兼容DC存在的意义:
	通常情况下，如果是同一类设备，创建的DC的初始化环境是相同的，
	问题在于设备DC在变化，运行过程中一定会调整属性，如果再创建一个同类设备的DC，初始属性肯定不一样，
	不兼容的可能性是很大的，所以以某个运行时刻的DC为基准创建一个兼容DC，将复制当前时刻的DC属性，
	它的属性可以保证是相同的，这才是兼容DC的目的，而不是直接使用CreateDC。
	
	因为兼容DC默认不包含位图，而DC本身的任何操作都是针对位图来操作的，所以创建兼容DC之后，必须也对应地创建一个兼容位图，否则任何绘制操作都是无效的，没有位图的兼容DC被BitBlt到目标DC之后，你会发现全是黑色的。

	如果像你的这种特殊需求，在创建兼容DC的时候还没有目标DC，那么通常都是以屏幕DC作为参考来创建兼容DC，因为最终所有的窗口都要显示在屏幕上。
	
	
	理解二： 

		我对兼容位图的理解是：它是为解决绘图统一性而建立的一种机制，和位深无关，你在32位的程序里BITBLT（）8位的图不也能行吗？

		所谓的绘图统一性是这样的。假设在一个界面有多个贴图，如果你不用兼容位图的话，那么你就要贴多次，比如有3幅图，你要贴3次，有5幅图你就要贴5次。

		如果你仅仅只想画一幅话的话，这也没什么，但在游戏领域就会造成大麻烦，因为游戏是要不断刷新图象的，而且是一秒钟要刷新几十次之多，这就是所谓的帧频，也就是说，在一秒钟内将屏幕上所有的图象绘几十次，如果屏幕上有5幅图，帧频是30次，那么你要在一秒钟内绘5*30=150次图，如果有10幅图，那就得绘300次，这会给显示系统造成很大负担，最显著的表现就是屏幕闪烁。

		而兼容位图能解决这一问题，它先把各个位图绘制到内存里，然后再一次性绘制到屏幕上，绘图次数就大大减少了，
		
		打个比喻，不用兼容位图绘图就好比是手动运货，你一次只搬一件货物过去，而兼容位图就是用集装箱运货，你先把所有的货物放到集装箱里，再一次运过去，这样你的劳动量就大大减少了
		
	
	
获取设备环境句柄的方法有两种：
	一是处理WM_PAINT消息时，通过BeginPaint函数返回。
	另外一种就是通过GetDC、GetWindowDC的API函数获取。
	

通过WM_PAINT消息获取DC
	Windows在检测到需要重新绘制或者刷新窗口时，会主动要求处理WM_PAINT消息。比如在如下情况下就会主动求处理：

		用户移动一个窗口，导致原来被盖住的部分窗口显示出来。
		用户调整窗口的大小，并且窗口风格类型设置为CS_HREDRAW和CS_VREDRAW。
		程序调用ScrollWindow或者ScrollDC函数滚动客户区。
		程序调用InvalidateRect或者InvalidateRgn函数，该函数显示生产一条WM_PAINT消息。
		
	我们可以在该消息中完成图文绘制，该消息的处理具有特定的格式，必须在实际绘制前调用BeginPaint，在绘制完成后调用EndPaint函数，也就是说我们需要把所有绘制的功能都放到这两个函数之间，并且HDC也只能在这之间使用，不能保存起来在其它地方使用。使用WM_PAINT有一个好处，就是windows会自己计算哪些区域需要更新，也就是说只有真正变化的地方才会更新，这样更新的代价会降低到最小。
	

通过API函数获取HDC
	我们还可以通过GetDC、GetWindowDC函数来获取HDC，但是要注意，通过这个来获取的HDC，可以保存起来在其它时候使用，但是要记住一旦窗口有更新，必须想办法重新绘制，否则就会消失了。最后在使用完毕后需要调用ReleaseDC来释放，否则会造成资源泄露。
	
	

创建特定字体
	我们平时最常见的文本输出是不需要自己创建字体的，因为常见的对象都有系统预定义好的。如果想输出点特殊（非系统预定义的）字体，就需要我们创建并自动选入设备环境。创建字体主要有CreateFont和CreateFontIndirect，这两个函数的参数都很多，基本一样，具体用法看后面的实例。
	

	
	
实现文本绘制
	有了上面的基础，我们就可以通过Windows的API来完成文本输出了，常用的文本输出函数有TextOut、DrawText、DrawTextExt、ExtTextOut等，这些函数基本都有相似的参数，比如hdc，坐标位置，字符串。下面TextOut、DrawText、ExtTextOut为例来说明如何在Windows窗口中如何输出文本，其它请查看MSDN的用法。
	
	
画图
	就少不了颜色的描述，Windows中的颜色有几种表示，其中COLORREF在GDI绘制中用的最多，
	它实际上是一个无符号32为整型。其中红、绿、蓝各占一个字节，最高字节不使用，如下图所
	该值可以用Windows提供的RGB宏来生成，Windows中RGB的定义为：
		#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))
	
	除此之外，Windows还有结构体RGBQUAD也表示颜色，这种一般用于位图结构信息中。	
	
	

画像素点
	Windows提供了SetPixel和GetPixel函数来设定和获取像素点的颜色。函数原型为：
		COLORREF SetPixel(HDC hdc, int X, int Y, COLORREF crColor);
		COLORREF GetPixel(HDC hdc, int nXPos, int nYPos);
	
画笔画刷
	在图形绘制之前，可以创建画笔给后续的画图使用，创建画笔的API函数为：

		HPEN CreatePen(int fnPenStyle, int nWidth, COLORREF crColor);
		HBRUSH CreateSolidBrush(COLORREF crColor);
		HBRUSH CreatePatternBrush(HBITMAP hbmp);
		HBRUSH CreateHatchBrush(int fnStyle, COLORREF clrref);
	它可以指定画笔风格，宽度和颜色。风格可以是实线、虚线、点虚线等，具体参考MSDN说明的各种类型。
	

画线条
	Windows提供的画线条函数有十几个，常用的直线绘制为LineTo，多条线段一般用Polyline、PolylineTo、PolyPolyine等，曲线可以画椭圆、椭圆弧、贝塞尔样条曲线。这些函数的原型请参考MSDN，后面我们将用实例来演示这些函数的用法。
	

封闭区域填充
	Windows的绘图如果是一个封闭区，则内部是可以填充的，当然如果你不显示填充，系统会用默认颜色来填，比如窗口背景色。我们也可以在绘制封闭图形之前创建画刷，如果把创建的画刷选入设备环境中，系统将用画刷填充内部区。常见的会封闭的绘图API函数有画直角矩形Rectangle、圆角矩形RoundRect、椭圆Ellipse、扇形图Pie以及弦割图Chord。

位图输出
	Windows关于位图的输出内容很多，包括设备相关和设备无关位图、以及位块转移、透明、缩放等等，本文仅针对位图画刷进行实例演示，其他内容将来可单独写一篇介绍。用位图做画刷时先要使用LoadImage函数加载位图文件，然后用CreatePatternBrush创建一个模式画刷即可。	
	

绘图属性

	在绘制图形时，环境设备有5个属性会影响大多数绘图：

	画笔位置：在画线条时，会从画笔所在的位置开始画，画笔位置可以用MoveToEx函数来设置。

	画笔：绘图时会采用当前环境中的画笔进行绘制，如果显示不创建，将会用系统默认的画笔。

	背景：某些GDI会有透明和不透明的设置。

	背景颜色：比如文本输出的间隙颜色。

	绘制模式：比如划线是可以设置实线、虚线等，填充时可能有不同的填充绘制模式。	
	
	

一幅位图只能被选入到一个兼容DC一次。例如下面代码就调用不成功：
    SelectObject(hdcA, hBitMap) ;
    ......
    SelectObject(hdcB, hBitMap) ;   //失败
    必须先将hdcA释放掉才能将hBitMap选入hdcB。

	
	
	
	
	


