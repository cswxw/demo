浮点数的表示方式:
	单精度 	32位：符号占1位，指数占8位，尾数中的小数部分占23位
	双精度 	64位：符号占1位，指数占11位，尾数中的小数部分占52位
	扩展精度 	80位：符号占1位，指数占16位，尾数中的小数部分占63位

以单精度为例，在内存中的储存格式如下（左边为高位）：
	| 1位符号 | 8位指数 | 23位尾数 |
	其中符号位1表示负数，0表示正数，这与整数形式的符号位意义相同； 科学计数法表示形式如 m * (b ^ e)，m为尾数，b为基数，e是指数，再二进制中，基数毫无疑问是2，对单精度，指数为中间8位二进制表示的数字，其中的尾数是形如1.1101 小数点后面的整数值。
	关于指数，由于需要表示正负两种数据，IEEE标准规定单精度指数以127为分割线，实际存储的数据是指数加127所得结果，127为高位为零，后7位为1所得，其他双精度也以此方式计算。
例子:
	float test = 123.456;

	int main()
	{
	return 0;
	}
	gcc -S test.cpp
		.file	"test.cpp"
		.globl	test
		.data
		.align 4
		.type	test, @object
		.size	test, 4
	test:
		.long	1123477881
		.text
		.globl	main
		.type	main, @function
	main:
	.LFB0:
		.cfi_startproc
		pushq	%rbp
		.cfi_def_cfa_offset 16
		.cfi_offset 6, -16
		movq	%rsp, %rbp
		.cfi_def_cfa_register 6
		movl	$0, %eax
		popq	%rbp
		.cfi_def_cfa 7, 8
		ret
		.cfi_endproc
	.LFE0:
		.size	main, .-main
		.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-28)"
		.section	.note.GNU-stack,"",@progbits
	
	打开反汇编后的文件，看到符号_test后定义的数字是 1123477881（这里gcc定义成了long类型，不过没有关系，因为都是四字节数字，具体的类型还得看如何使用）。
	可以使用计算器把十进制数字转化为二进制：0 10000101 11101101110100101111001，
	这里根据单精度的划分方式把32位划分成三部分，符号位为0，为正数，指数为 133，减去127得6，尾数加上1.，形式为1.11101101110100101111001，扩大2 ^ 23次方为111101101110100101111001，十进制16181625，后除以2 ^ (23 – 6) = 131072，结果为123.45600128173828125，与我们所定义的浮点数正好相符。
	

浮点数寄存器:
	FPU有 8 个独立寻址的80位寄存器，名称分别为r0, r1, …, r7，他们以堆栈形式组织在一起，统称为寄存器栈，编写浮点指令时栈顶也写为st(0)，最后一个寄存器写作st(7)。
	FPU另有3个16位的寄存器，分别为控制寄存器、状态寄存器、标记寄存器，现一一详细说明此三个寄存器的作用：
	状态寄存器，为用户记录浮点计算过程中的状态，其中各位的含义如下：
		0 —— 非法操作异常
		1 —— 非规格化操作数异常
		2 —— 除数为0异常
		3 —— 溢出标志异常
		4 —— 下溢标志异常
		5 —— 精度异常标志
		6 —— 堆栈错误
		7 —— 错误汇总状态
		8 —— 条件代码位0（c0）
		9 —— 条件代码位1（c1）
		10 —— 条件代码位2 （c2）
		11-13 —— 堆栈顶指针
		14 —— 条件代码位3（c3）
		15 —— 繁忙标志
	其中读取状态寄存器内容可使用 fstsw %ax
	
	控制寄存器的位含义如下：
		0 —— 非法操作异常掩码 
		1 —— 非法格式化异常掩码 
		2 —— 除数为0异常掩码 
		3 —— 溢出异常掩码 
		4 —— 下溢异常掩码 
		5 —— 精度异常亚曼 
		6-7 —— 保留 
		8-9 —— 精度控制（00单精度，01未使用，10双精度，11扩展精度） 
		10-11 —— 舍入控制（00舍入到最近，01向下舍入，10向上舍入，11向0舍入） 
		12 —— 无穷大控制 
		13–15 —— 保留
	其中读取控制寄存器和设置控制寄存器的指令如下：	
		# 加载到内存
		fstcw control
		# 加载到控制器
		fldcw control
				
	最后的标志寄存器最为简单，分别0-15位分别标志r0-r7共8个寄存器，每个寄存器占2位，这两位的含义如下：	
		11 —— 合法扩展精度 
		01 —— 零 
		10 —— 特殊浮点 
		11 —— 无内容	
				
	另外对浮点寄存器的一些控制指令如下：	
		# 初始化fpu，控制、状态设为默认值，但不改变fpu的数据
		finit

		# 恢复保存环境
		fldenv buffer
		fstenv buffer

		#清空浮点异常
		fnclex

		#fpu状态保存
		fssave
	
	fstenv 保存控制寄存器、状态寄存器、标记寄存器、FPU指令指针偏移量、FPU数据指针，FPU最后执行的操作码到内存中。	
		
		
浮点数指令(AT&T语法)
	finit 	初始化控制和状态寄存器，不改变fpu数据寄存器
	fstcw control 	将控制寄存器内容放到内存control处
	fstsw status 	将状态寄存器内容放到内存status处
	flds value 	加载内存中的单精浮点到fpu寄存器堆栈
	fldl value 	加载内存中的双精浮点到fpu寄存器堆栈
	fldt value 	加载内存中的扩展精度点到fpu寄存器堆栈
	fld %st(i) 	将%st(i)寄存器数据压入fpu寄存器堆栈
	fsts value 	单精度数据保存到value，不出栈
	fstl value 	双精度数据保存到value，不出栈
	fstt value 	扩展精度数据保存到value，不出栈
	fstps value 	单精度数据保存到value，出栈
	fstpl value 	双精度数据保存到value，出栈
	fstpt value 	扩展精度数据保存到value，出栈
	fxch %st(i) 	交换%st(0)和%st(i)
	fld1 	把 +1.0 压入 FPU 堆栈中
	fldl2t 	把 10 的对数(底数2)压入 FPU 堆栈中
	fldl2e 	把 e 的对数(底数2)压入 FPU 堆栈中
	fldpi 	把 pi 的值压入 FPU 堆栈中
	fldlg2 	把 2 的对数(底数10)压入 FPU 堆栈中
	fldln2 	把 2 的对数(底数e) 压入堆栈中
	fldz 	把 +0.0 压入压入堆栈中	
		
	以上指令虽多，但是还是很有规律，
		前缀f表示fpu操作，
		ld加载，
		st保存设置，
		p后缀弹出堆栈，
		s、l、t后缀表示单精度，双精度，扩展精度，
		c后缀表 示控制寄存器，
		s后缀表示状态寄存器。
		当然这仅仅是对AT&T语法而言，对MASM语法没有s，l，t之分，需要使用type ptr来指明精度，即内存大小。	
		
		
	学会灵活的加载弹出数据堆栈后，接下来就要看一些基本的计算：	
		fadd    浮点加法
		fdiv    浮点除法
		fdivr   反向浮点除法
		fmul    浮点乘法
		fsub    浮点减法
		fsubr   反向浮点减法
		
	对于以上的每种指令，有几种指令格式，以fadd为例，列举如下：	
		# 内从中的32位或者64位值和%st(0)相加
		fadd source

		# 把%st(x)和%st(0)相加，结果存入%st(0)
		fadd %st(x), %st(0)

		# 把%st(0)和%st(x)相加，结果存入%st(x)
		fadd %st(0), %st(x)

		# 把%st(0)和%st(x)相加，结果存入%st(x)，弹出%st(0)
		faddp %st(0), %st(x)

		# 把%st(0)和%st(1)相加，结果存入%st(1)，弹出%st(0)
		faddp

		# 把16位或32位整数与%st(0)相加，结果存入%st(0)
		fiadd source
		
		
		
		
		
		
		
		
		
	
